\chapter{Literature Review}
\label{chap:lr}
\chaptermark{Second Chapter Heading}

This chapter will begin with an overview of persistence concept in general,
and in particular, orthogonal persistence in Section 1. Then, Section 2 will
discuss how networking in persistent systems was implemented previously, and
what are the requirements for a networking stack in such systems. The last
section describes Phantom OS, Genode OS framework and current state of
porting former to latter.

\section{Persistence}
\subsection{Persistence definitions}
Every program operates data. These data can be different in nature,
and thus have different lifetimes. The lifetime of a data object is a time extent
over which it can be used and is commonly called \textit{persistence} 
\cite{atkinson1983ps}. 

Atkinson \textit{et al.} \cite{atkinson1995orthogonally,atkinson1983ps} give a 
classification of application data objects by their persistence, which is
presented in Table \ref{tab:data_lifetimes}. Usually, support of levels 1-4
relies on programming languages themselves, and for levels 5-8 designers of
persistent applications rely on some external component, such as database or 
file system. 

\begin{longtable}{cl}
\caption[Classification of data objects based on their lifetime]{Classification 
of data objects based on their lifetime} 
\label{tab:data_lifetimes} \\
\hline
1. & Transient results in expression evaluation \\
2. & Local variables inside functions and code blocks \\
3. & Global variables and heap items \\
4. & Data that exists throughout a whole execution of a program \\
5. & Data that lasts for several executions of program \\
6. & Data that lasts for as long as a program is being used \\
7. & Data that outlives a program \\
\hline
\end{longtable}

\subsection{Orthogonal persistence}
\label{sec:LR:orth-persistence}

Different ways of data interactions, namely using builtin programming language 
constructs and external tools available via some interfaces, bring an extra
layer of complexity to programs. To answer this problem, 
\cite{atkinson1995orthogonally} proposes to use persistent support systems, 
which act as a mediator between a persistent application and transient 
environment. Atkinson \textit{et al.} also summarize requirements for such a
system, saying that such a systems should have use of data not dependent of its
persistence. They define following principles for such a system:
\begin{enumerate}
    \item The Principle of Persistence Independence. 
    
    Whether a program manipulates data that outlives it or not, the ways to use
    these data should be the same. There should be no significant difference in
    program syntax in either case.

    \item The Principle of Data Type Orthogonality. 
    
    Every data object should be allowed to have any level of persistence, 
    irrespective of their type. There should be no special cases where objects
    of some type can not be persistent or transient.
    
    \item  The Principle of Persistence Identification. 
    
    The choice of how to identify which objects are persistent and how To
    provide persistence to them objects is not related to the universe of 
    discourse of the system. The mechanism for identifying persistent objects 
    should not also be related to the type system.

\end{enumerate}

Two popular approaches exist to build such a system. 

One is to integrate interactions with databases or file systems into an existing 
programming languages, which is what most ORM libraries do 
\cite{аннин2018краткий,copeland2008essential}. However, this approach is not 
really transparent for a programmer, and may cause errors. 

Another approach is to build the so-called \textit{persistent worlds} 
\cite{atkinson1995orthogonally}. These worlds usually have form of 
operating systems, which provide required mechanisms to make state of   
userspace processes persistent across systems restarts. 
Examples of such systems are KeyKOS \cite{bomberger1992keykos}, Grasshopper OS
\cite{dearle1994grasshopper}, and Phantom OS.

A question may arise at this point, can an existent popular operating system, 
run with nonvolatile memory as a main memory, and if it will make it 
orthogonally persistent?
The answer is no, because this approach raises two problems: problem of dealing
with changed peripheral device states during restarts 
\cite{berthou2018peripheral}, and logical problems with code execution 
\cite{ransford2014nonvolatile}. A persistent support system must satisfy 
orthogonal properties. Therefore building such a system is not trivial.

\section{Networking in persistent systems}
\dots This part is not done yet, because research on this is still in progress.
However an outline was done for its contents
\begin{enumerate}
    \item Definition of problems with currently supported network stack. \\
    Example of problems:
    \begin{itemize}
        \item Lost connections and strategies to restore. 
        \item How stateful protocols can be changed? 
        \item Can we use some intermediary message broker to manage 
        communication?
    \end{itemize} 
    \item Define requirements for protocol that are suitable for PSs
    \item Say what will be focus of work
\end{enumerate} 

\section{Phantom OS and Genode OS framework}
\subsection{Phantom OS}
Phantom OS is a general-purpose operating system, developed in 2009-2011. This 
is an orthogonally persistent operating system, in which persistence is brought
using snapshotting of virtual memory. The operating system consists of kernel 
and virtual machine, which executes all userspace programs written in Phantom 
bytecode. Managed code execution is persistent, whereas kernel state is 
transient, which means that it is not kept between reboots. It is assumed that 
it can be restored. 
Phantom is an experimental system, in a sense that it is developed as a 
proof-of-concept and is not ready for production use.

Phantom OS currently supports only i386 ISA, and it has all drivers builtin 
inside a kernel. It is problematic, because to support wide range of hardware
OS needs drivers, which is often delivered by third-party developers. But in
case when drivers are embedded in kernel error in driver can crash whole system.

These are two reasons why it is desirable to replace Phantom kernel with a 
microkernel. My colleagues from Innopolis University are now working on porting
Phantom OS to Genode OS  framework. I am going to use this port as soon as it 
will be ready.

\subsection{Genode OS framework} 
The Genode OS Framework \cite{feske2015genode} is a toolkit for creating 
operating systems. It provides possibility to build a microkernel operating \
systems from set of existing components. Genode provides an API to integrate 
various microkernels into it.

For now the supported ones include Linux kernel, nova microhypervisor and several
kernels from L4 kernel family. Supported kernels from the last family include
L4ka::Pistachio, Fiasco.OC, formally verified seL4 microkernel, and L4/Fiasco.
The framework also supports execution on a bare hardware on ARM and x86-64 ISA.

Components provided by Genode usually fall into five categories: device drivers,
resource multiplexers, protocol stacks, applications and runtime environments.